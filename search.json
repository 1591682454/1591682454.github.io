[{"title":"老电脑刷入nvme协议","date":"2021-03-24T17:00:01.000Z","url":"/2021/03/25/%E8%80%81%E7%94%B5%E8%84%91%E5%88%B7%E5%85%A5nvme%E5%8D%8F%E8%AE%AE/","tags":[["电脑","/tags/%E7%94%B5%E8%84%91/"]],"categories":[[" ",""]],"content":"老电脑bios刷入NVME模块 Page 1 前几天买了根西数sn550给笔记本当系统盘没想到bios不支持。在系统中是能读到这个磁盘的，但是在bios中不显示磁盘也无法设置为启动项。 难道就只能当个副盘？那系统不是还和以前一样慢？ 不不不，修仙之人岂能受如此委屈？ 先来看看笔记本型号，神舟战神Z6-I78172D1，很容易就在网上能找到磁盘位的信息。 一个m.2接口？ 这不是能直接用？ 后来找了很多资料才发现问题所在，现在的m.2接口确实支持SATA协议和NVME协议，但是在15年m.2接口只支持SATA协议。这我就纳闷了，你说这吧，插都能插进去你整这出？ 后来发现确实能插进去，也能用，只是速度会限制为sata协议的速度降了不止一倍。这明显不是我想看到的。 本来我都打算放弃的，但是退一步越想越气o（′益`）o 继续到了找资料的途中，说来确实不愧是老电脑了，论坛贴吧能找的资料少之又少，不过还好留下了刷NVME的词条。顺着这个词条我找到了很多相似经历的小伙伴的记录，虽然型号不同，但是可以作为参考。 网址： 根据这个教程，我大致理了一下思路。 思路有了那就开始动手，首先根据上面那篇博文说的，我们来到了蓝天模具BIOS下载地址：  用户名密码均为repo 一进去我也有点懵，全是英文，右键一键翻译，我又行了。首先要知道自己笔记本用的啥模具，进bios就可以看到。比如我的就是N151SD，回到网页点进去就是下图。好家伙最近更新日期2015/09/14 这是刚出来就停更了？反正又不是不能用.jpg。分析描述可以得知，这里下载BIOS包要注意，刷入bios有EC固件版本要求，也就是说我们要先刷EC固件再刷BIOS。 到这里准备我就已经具备了刷BIOS的条件，因为我U盘已经做过了微PE启动盘。 后面就是修改BIOS了，具体参考下面吾爱的教程。 网址： 这里需要打开bios文件，打开下载好的bios包，观察可知两个.0后缀的文件应该就是bios了。 修改完成替换进之前下载好的bios包。 这里已经我修改好了bios，接下来回到刷BIOS的那篇博文，照着输入命令即可。 成功后开机logo会变成蓝天的，如果失败会开不了机还可能搞坏主板啥的，刷坏bios需要到电脑店找专门的机器刷。 简单来说，就是逆天改命渡雷劫一般，成则实力大进，败则灰飞烟灭。 不过吾辈修仙之人岂可退缩，区区雷劫而已。 后来在B站看到一个同型号已经渡劫成功的视频  ，有需要也可以找那个up取取经。 这里说说有些要注意的事项： 1、u盘启动dos工具箱刷bios只会识别u盘，u盘要格式化为fat16更好。我是这样的，不知道其他人。 2、我用微pe进dos工具箱刷不了换成大白菜就好了。虽然是流氓PE但只要不拿来装系统就没太大问题。 -————————— 刷BIOS有风险 你必须知道自己在做什么 -————————— 刷完就简单了，迁移系统，修复引导，进bios改引导项(虽然刷入了nvme协议但是bios中并不会显示，只是可以看到引导项有这块磁盘的)。开机发现开机速度明显变快。成功进入系统完美。 接下来放一张测速图 这个速度已经超过了sata协议的速度， 所以这代表我刷成功了。 -————————— 刷BIOS有风险 你必须知道自己在做什么 -————————— END"},{"title":"promise的理解","date":"2021-03-22T08:28:45.000Z","url":"/2021/03/22/promise%E7%9A%84%E7%90%86%E8%A7%A3/","tags":[["javascript","/tags/javascript/"]],"categories":[[" ",""]],"content":"romisepromise1、promise的简单理解promise n. 许诺，允诺；希望 vt. 允诺，许诺；给人以……的指望或希望 vi. 许诺；有指望，有前途 可以理解为promise一定会给你一个承诺，无论是好是坏。 2、async及await async和await是现在异步加载的最好方案。 在es5通常是这样做的 这称之为回调地域，为了避免这种情况promise出现了。 这种调用明显好看了许多。 async和await其实也是promise的语法糖 看一个例子 await 表示这里会停下执行这个函数，只有这个函数执行完才会继续往下执行 如果没有它，我们无法预料两个异步函数谁会先执行完。"},{"title":"git基础使用","date":"2021-03-22T08:04:35.000Z","url":"/2021/03/22/git%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/","tags":[["学习","/tags/%E5%AD%A6%E4%B9%A0/"]],"categories":[[" ",""]],"content":"git基础使用1.1 git init初始化 到文件夹目录执行git init 1.2 git add 添加文件 使用git add . 添加所有文件 使用git add index.html 添加index.html这个文件 1.3 git status 查看状态 添加index.html的状态（改变已提交） 修改index.html再看看（改变需提交） 1.4 git commit -m “描述” 提交 git commit -m “第一次提交” 这里已经提交了成功，并创建了mode为100644 1.5 git log 查看全部提交信息 git log 这里已经看到了之前我提交的那次记录，并且记录了提交者和提交时间 1.6 git reset -- hard HEAD^回滚版本首先，Git必须知道当前版本是哪个版本，在Git中，用HEAD表示当前版本，也就是最新的提交1094adb...（注意我的提交ID和你的肯定不一样），上一个版本就是HEAD^，上上一个版本就是HEAD^^，当然往上100个版本写100个^比较容易数不过来，所以写成HEAD~100。 现在，我们要把当前版本append GPL回退到上一个版本add distributed，就可以使用git reset命令 这里我新增了一个style.css文件并完成了第二次提交 但是我反悔了，因为第二次提交的代码有bug 接下来我想恢复到第一次的版本 这里失败了，windows的cmd必须这样 git reset –hard “HEAD^” 具体原因看看csdn解答 这里显示HEAD is now at 23f2ee4 第一次提交,表示已经回滚到了第一次提交的时候 git log 已经没有了第二次提交的记录，如果我们梅开二度又反悔了怎么办？ 如果你知道commit 的唯一码就好办了，当然只要前几位其他的git会自己去找 例如 第一次提交就是 23f2… ​ 第二次提交就是 302e… git reset –hard 302e03 哎，我又回来了(如果没备份吃commit码建议去网上寻找答案) 1.7 git checkout -- file丢弃工作区的修改命令git checkout -- readme.txt意思就是，把readme.txt文件在工作区的修改全部撤销，这里有两种情况： 一种是readme.txt自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态； 一种是readme.txt已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。 总之，就是让这个文件回到最近一次git commit或git add时的状态。 误删的文件也可以用git checkout – file 找回，当然前提是未提交已删除的版本 1.8 git remote add origin 远程仓库地址remote 遥远的 origin 可以自定义代表仓库的名字 例如我的 git remote add res  使用git remote -v查看当前远程仓库地址 使用git branch -a 查看远程仓库地址 1.9 git push -u origin master git push -u res master 推送当前分支版本到名为res的远程仓库 推送结果 然后到gitte看，果然已经推送成功 ps:把本地库的内容推送到远程，用git push命令，实际上是把当前分支master推送到远程。 由于远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。 2.0 git clone 地址 克隆项目clone 克隆 git clone  2.1 git branch dev 创建名为dev的分支 创建分支 dev 切换到分支dev 前面两条命令的合并 2.2 git merge dev 合并名为dev的分支上面我已经创建并切换到了dev分支，在这个分支的操作不会影响master分支 我写了一个js文件并提交到了dev分支 提交成功！！！ 提交dev分支到res远程仓库 然后我发现dev分支确实做的不错，想要合并到master分支 切换到 master分支,合并修改 到这里就已经合并完成了，master分支已经同步过去了，已经是本地commit但git log 并未显示。 git push res master 由于远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。 "},{"title":"tags","date":"2021-03-22T07:03:25.000Z","url":"/tags/index.html","categories":[[" ",""]]},{"title":"categories","date":"2021-03-22T07:08:01.000Z","url":"/categories/index.html","categories":[[" ",""]]},{"title":"search","date":"2021-03-22T07:10:34.000Z","url":"/search/index.html","categories":[[" ",""]]},{"title":"友链","date":"2021-03-22T07:10:34.000Z","url":"/friends/index.html","categories":[[" ",""]]},{"title":"page","date":"2021-03-22T08:01:29.000Z","url":"/page/index.html","categories":[[" ",""]]}]